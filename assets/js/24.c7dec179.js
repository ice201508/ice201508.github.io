(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{479:function(e,t,a){"use strict";a.r(t);var s=a(10),v=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue3-随堂面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-随堂面试题"}},[e._v("#")]),e._v(" VUE3 随堂面试题")]),e._v(" "),t("blockquote",[t("p",[e._v("可以参考的一些面试题答案， vue3上课比掌握的面试题")])]),e._v(" "),t("h3",{attrs:{id:"_1-技术栈-用过哪些vue相关-ui组件库-js-cookie-qs-axios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-技术栈-用过哪些vue相关-ui组件库-js-cookie-qs-axios"}},[e._v("#")]),e._v(" 1.技术栈，用过哪些vue相关 UI组件库 (js-cookie  qs axios)")]),e._v(" "),t("p",[e._v("vue2：element-ui（后台管理） ant-design-vue（后台管理https://2x.antdv.com/docs/vue/introduce-cn）  vant-ui（移动端） ArcoDesign（字节后台管理 https://arco.design/） TDesign（腾讯企业级设计 https://tdesign.tencent.com/） Naive UI（尤玉溪推荐  内置 80+组件 https://www.naiveui.com/zh-CN/os-theme）")]),e._v(" "),t("p",[e._v("vue3： element-plus（后台管理）  ant-design-vue (后台管理)  vant-ui（移动端）")]),e._v(" "),t("p",[e._v("小程序： 采用uni-app 框架才能使用 uview-ui这个框架，还有 vant-ui")]),e._v(" "),t("h3",{attrs:{id:"_2-vue3-比-vue2的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue3-比-vue2的优点"}},[e._v("#")]),e._v(" 2.Vue3 比 Vue2的优点")]),e._v(" "),t("blockquote",[t("p",[e._v("proxy + defineProperty， ts， 组合式api")])]),e._v(" "),t("ol",[t("li",[e._v("底层数据响应式原理重新实现（ES6 proxy 替代了 ES5 的 Object.defineProperty）")]),e._v(" "),t("li",[e._v("全面采用ts，更好的类型推导")]),e._v(" "),t("li",[e._v("提供了组合式api，更适合大型项目； vue2组件复用一般才有mixin，有缺陷，一般在中小型项目里面。 vue2采用的是选项式api")])]),e._v(" "),t("p",[e._v("（以前大公司里面 react开发大型项目， vue2中小型项目开发（项目大了以后，组件不是很好复用）vue3改进了以后，比较适合开发大型项目）")]),e._v(" "),t("h3",{attrs:{id:"_3-vite与vue-cli区别-1-说他们的底层-2-现在企业使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-vite与vue-cli区别-1-说他们的底层-2-现在企业使用场景"}},[e._v("#")]),e._v(" 3.vite与vue-cli区别 （1.说他们的底层 2.现在企业使用场景）")]),e._v(" "),t("blockquote",[t("p",[e._v("vite--ESM 浏览器原生模块，不需要打包，所以快")]),e._v(" "),t("p",[e._v("vue-cli  webpack 生态比较全，现在公司用的多，打包稍微慢一点")])]),e._v(" "),t("p",[e._v("(vue-cli可以创建vue2 3的项目  vite可以创建 vue3，react项目)")]),e._v(" "),t("ol",[t("li",[e._v("vue-cli --- 底层依赖于 webpack -- 开发的时候，webpack会给你打包，项目大了以后，启动速度就很慢")])]),e._v(" "),t("p",[e._v("vite - 开发环境： 依赖于 浏览器原生 es6 modules-- 不需要打包； 生产环境依赖于 rollup打包构建")]),e._v(" "),t("ol",[t("li",[e._v("vue-cli 既可以开发vue2 也可以开发vue3项目- 但是官网不推荐。 开发vue3官方推荐使用vite，更快的启动速度")]),e._v(" "),t("li",[e._v("很多大企业，还是使用vue-cli； 因为底层依赖于webpack，这个出现了很多年，周边的一些生态（webpack的一些工具，很多人在开发，比较成熟）。 vite出现时间短，生态比较少（网上的一些周边插件比较少，所以现在大公司还是 webpack为主）")]),e._v(" "),t("li",[e._v("vite 既可以开发 vue 也可以开发react。 webpack也是既可以开发 vue，也可以开发react")])]),e._v(" "),t("p",[t("strong",[e._v("vue-cli底层是什么？ 为什么看不见webpack.config.js文件？")]),e._v(" （非面试题，自己的基本常识）")]),e._v(" "),t("blockquote",[t("p",[e._v("vue2项目 依赖于 vue-cli 脚手架创建， 这个脚手架底层又是依赖于webpack， 而webpack开发项目，又是需要自己配置一些loader plugin等等参数，但是项目里面没有webpack.config.js文件， 只有 vue.config.js文件，因为vue-cli脚手架给我把webpack封装起来了。")]),e._v(" "),t("p",[e._v("如果你硬要看webpack的配置文件， 在vue-cli的项目，直接输入 vue inspect 可以查看 vue.config.js 编译为 webpack.config.js文件以后的 内容")])]),e._v(" "),t("p",[t("strong",[e._v("vue2 3 文件的区别")]),e._v("（非面试题，自己常识）")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("index.html vue2在public文件夹里面， vue3在 src文件夹的外面")])]),e._v(" "),t("li",[t("p",[e._v("入口文件main.js， vue2是new Vue 构造函数，里面绑定App根组件")]),e._v(" "),t("p",[e._v("vue3 是 createApp这个函数，函数的参数是一个App根组件，")])]),e._v(" "),t("li",[t("p",[e._v("vue2的vscode的插件 vetur。 但是vue3的插件是 volar。 开发vue3项目，需要禁用")])]),e._v(" "),t("li",[t("p",[e._v("vue3 可以有多个元素并排，不一定只有一个根元素root。 vue2只能有一个根元素")])]),e._v(" "),t("li",[t("p",[e._v("vue3项目里面可以写 vue2的语法，可以加选项式api，但是不推荐")])]),e._v(" "),t("li",[t("p",[e._v("自己在vscode里面，配置一些代码片段，提升开发效率， 以前配置过 try...catch的片段（点击左下角的齿轮按钮，点击配置用户代码片段，把刚刚那个json复制进去）")])]),e._v(" "),t("li",[t("p",[e._v("因为vue3 发布了很久了，最开始的语法，比较繁琐，然后经过两年的更新，我们就使用的是新语法， script标签上面，添加 setup属性， 不用在return导出了，js里面的变量，外面可以直接看见")])])]),e._v(" "),t("h3",{attrs:{id:"_4-setup是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-setup是什么"}},[e._v("#")]),e._v(" 4.setup是什么？")]),e._v(" "),t("p",[e._v("1.是vue3，钩子函数（生命周期函数），代替了以前vue2的 beforeCreated和created两个钩子函数")]),e._v(" "),t("p",[e._v("2.这个函数里面不能访问 this值，在这个函数里面写一些钩子函数，需要手动从vue里面导入进来，写了setup，就不要使用vue2的哪一种 选项式的api，")]),e._v(" "),t("h3",{attrs:{id:"_5-reactive-与-ref-是什么以及有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-reactive-与-ref-是什么以及有什么区别"}},[e._v("#")]),e._v(" 5. reactive 与 ref 是什么以及有什么区别？")]),e._v(" "),t("p",[e._v("1.ref，定义响应式数据的一个方法，在就是里面访问值，需要.value，在html模板里面，不需要.value")]),e._v(" "),t("p",[e._v("2.如果是普通数据类型，我们一般使用ref定义，如果是复杂数据类型，我们采用reactive进行包裹，让对象具有响应式。 但是ref也可以定义复杂数据类型")]),e._v(" "),t("p",[e._v("（vue2里面，数据只需要写到data上面，vue的底层代码，Object.definedProperty会把data上面的所有数据，自动转换为响应式数据。 vue3不行，需要我们通过ref reactive这两个函数，手动去转换普通数据类型和复杂数据类型，为响应式数据）")]),e._v(" "),t("blockquote",[t("p",[e._v("vue2里面做过哪些优化 ！！！")])]),e._v(" "),t("p",[e._v("1.你说我之前在写vue代码的时候，对于使用元素dom绑定事件，和原生js的定时器的时候。需要在destroyed钩子函数里面，将dom事情移除removeEventListener，以及定时器移除clearInterval")]),e._v(" "),t("p",[e._v("2.还做过一些优化，就是有些数据例如 定时器的返回值timerId，这样的数据，不需要进行页面渲染，我们只是在销毁的钩子函数里面使用以下，这个时候就不需要定义到data上面，增加系统负担，因为this是一个对象，只要给他添加一个属性即可。减少不必要的 数据响应式处理")]),e._v(" "),t("blockquote",[t("p",[e._v("vue3组合式api的 使用方式，自定义两个方法导出，抽离封装一个具体的功能性模块")])]),e._v(" "),t("h3",{attrs:{id:"_6-计算属性有几种写法-计算属性可以传参吗-vue2和3使用区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-计算属性有几种写法-计算属性可以传参吗-vue2和3使用区别"}},[e._v("#")]),e._v(" 6. 计算属性有几种写法？ 计算属性可以传参吗？vue2和3使用区别？")]),e._v(" "),t("p",[e._v("1.有两种写法，一种是默认的 get方法，直接函数里面写return")]),e._v(" "),t("p",[e._v("还有一种是有get  set两种写法，设置set的时候，可以更改另一个属性的值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// vue3 计算属性 第一种写法 (就叫get方法，没有set)\nconst nextAge = computed(() => {\n  // 字符串转数字： +  Number  parseInt  parseFloat\n  return +age.value + 1\n})\n\n// // vue3 计算属性 第二种写法， 带有set参数，可以设置\nconst afterAge = computed({\n  get() {\n    return +age.value + 2\n  },\n  set(val) {\n    age.value = val - 2\n  }\n})\n")])])]),t("ol",[t("li",[t("p",[e._v("计算属性可以传参，是通过函数返回一个函数的形式，可以自定义各种数据显示")]),e._v(" "),t("p",[e._v("计算属性vue2 3 都可以传参，只要依赖的数据不发生改变，依然有缓存。可以按需做一些动态的数据显示")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<div>{{ selfAge(2025, '20k') }}</div>\n<div>{{ selfAge(2027, '25k') }}</div>\n<div>{{ selfAge(2030, '35k') }}</div>\n\nconst selfAge = computed(() => {\n  console.log('虽然传递了参数，但是age.value值没有改变，依然会走缓存，上面调用三次，这里只会执行一次，因为age.value没有发生变化');\n  return function(a, b) {\n    return a + '年我' + age.value + '希望月薪' + b\n  }\n})\n")])])]),t("ol",[t("li",[t("p",[e._v("和vue2的区别")]),e._v(" "),t("p",[e._v("vue2是通过 computed 选项 配置来写的")]),e._v(" "),t("p",[e._v("vue3需要导入一个函数")])])]),e._v(" "),t("blockquote",[t("p",[e._v("字符串转换数字的几种方法\n"),t("code",[e._v("+ Number parseInt parseFloat")])])]),e._v(" "),t("h3",{attrs:{id:"_7-监听器的使用vue2与3区别-常识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-监听器的使用vue2与3区别-常识"}},[e._v("#")]),e._v(" 7. 监听器的使用vue2与3区别（常识）")]),e._v(" "),t("p",[e._v("vue2和vue3的写法不一样，一个是配置，一个是导入一个watch函数")]),e._v(" "),t("p",[e._v("还有vue3监听的时候，可以传递一个数组，监听多个属性。")]),e._v(" "),t("p",[e._v("多了几个watchEffect相关的函数")]),e._v(" "),t("h3",{attrs:{id:"_8-vue2和3使用防抖-优化-简历里面可写-网上很多说法都是错误的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue2和3使用防抖-优化-简历里面可写-网上很多说法都是错误的"}},[e._v("#")]),e._v(" 8. vue2和3使用防抖  --- 优化 -- 简历里面可写！！！ ---网上很多说法都是错误的")]),e._v(" "),t("p",[e._v("1.vue里面防抖一般使用在 watch 和 method上面 （防抖是 单位时间以内，只执行最后一次函数，一般用在搜索框的优化上面）")]),e._v(" "),t("p",[e._v("2.一般有两种写法")]),e._v(" "),t("p",[e._v("第一种：在created里面，在this上定义一个新函数，接受debounce的返回值")]),e._v(" "),t("p",[e._v("第二种方法：在methods里面定义方法的时候，不推荐 -- 因为如果这个组件在当前页面使用的多次，那么防抖可能出现故障 ---这个就类似于 data为什么必须一个函数的问题，组件每次新建，都必须是一个新地址，防抖函数也不例外")]),e._v(" "),t("p",[e._v("3.关于防抖的优化 （提高点）")]),e._v(" "),t("p",[e._v("优化watch的调用，还需要注意在 离开当前组件之前，最后一次防抖函数需要手动调用cancel取消，或者flush立即执行")]),e._v(" "),t("p",[e._v("（在destroyed钩子函数里面， 已经有三个优化了： remove 事件绑定，clearInterval清除定时器， 取消防抖的函数执行）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vue3 里面定义方法的时候，直接在setup里面使用 防抖函数包裹一下\nconst valueChnage = _.debounce(() => {\n  console.log(val.value);\n}, 500)\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vue2里面有两种方法\n第一种：\n在created里面，在this上定义一个新函数，接受debounce的返回值\ncreated () {\n  this.debounceInput = this.debounce(this.handle, 1000,false)\n}\n\n第二种方法：\n在methods里面定义方法的时候，不推荐 -- 因为如果这个组件在当前页面使用的多次，那么防抖可能出现故障 ---这个就类似于 data为什么必须一个函数的问题，组件每次新建，都必须是一个新地址，防抖函数也不例外\nchangeValue: _.debounce((e) => {\n  console.log(e, this);\n}, 500)\n")])])]),t("h3",{attrs:{id:"_9-data为什么必须是一个函数-props针对复杂数据类型也为什么必须是函数返回一个数组或者对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-data为什么必须是一个函数-props针对复杂数据类型也为什么必须是函数返回一个数组或者对象"}},[e._v("#")]),e._v(" 9. data为什么必须是一个函数， props针对复杂数据类型也为什么必须是函数返回一个数组或者对象？")]),e._v(" "),t("p",[e._v("如果组件复用了多次， data不是一个函数的话，那么多个相同组件使用的data就是同一个地址，那么修改一个组件就会到导致其他组件 的数据也发生改变，就会产生bug")]),e._v(" "),t("p",[e._v("（上面回答完以后，你接下来再说）我们还有父向子传值的时候，对于复杂数据类型props定义默认值的时候，也是需要写一个函数，返回给一个新地址的形式，不能直接写对象或者数组，因为是同一个地址")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("props: {\n  list: {\n    type: Array,\n    // default: []\n    default: () => []\n  }\n},\n")])])]),t("h3",{attrs:{id:"_10-computed-method-watch-区别-和别的班级的-拔高点-回答深入一些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-computed-method-watch-区别-和别的班级的-拔高点-回答深入一些"}},[e._v("#")]),e._v(" 10. computed method watch 区别？----- 和别的班级的 拔高点-回答深入一些")]),e._v(" "),t("blockquote",[t("p",[e._v("缓存， 业务， 监听")])]),e._v(" "),t("p",[e._v("methods：执行n次，运行n次函数 --- 强调函数调用。methods 方法表示一个具体的操作，主要书写业务逻辑\ncomputed： 页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性。比如以前使用过滤器，现在vue3没有了，我们就可以用计算属性代替。 而且他有最重要的特性，有缓存。有些情况下，调用computed中函数n次，如果依赖数据没有变化，只会执行一次函数，因为使用的缓存里面的数据，不用调用函数 -- 强调属性调用。但是利用返回函数的形式，也可以在模板上调用并传参 "),t("strong",[e._v("计算属性可以传参")]),e._v("\nwatch：类似于监听+事件的机制， 监听的值一旦发生改变，就执行后面的回调函数。 一遍用来监听data props $route等参数的变化")]),e._v(" "),t("p",[e._v("总结：大部分情况下watch和computed几乎没有差别。但如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch是最佳选择。watch可以看作是 computed 和 methods 的结合体")]),e._v(" "),t("h3",{attrs:{id:"_11-vue2-和-vue3的响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue2-和-vue3的响应式原理"}},[e._v("#")]),e._v(" 11. Vue2 和 Vue3的响应式原理")]),e._v(" "),t("blockquote",[t("p",[e._v("使用proxy代替defineProperty")])]),e._v(" "),t("p",[t("code",[e._v("Vue2")]),e._v("是通过数据劫持的方式来实现响应式的，其中最核心的方法便是通过"),t("code",[e._v("Object.defineProperty()")]),e._v("来实现对属性的劫持，该方法允许精确地添加或修改对象的属性，对数据添加属性描述符中的"),t("code",[e._v("getter")]),e._v("与"),t("code",[e._v("setter")]),e._v("存取描述符实现劫持。"),t("code",[e._v("Vue2")]),e._v("之所以只能兼容到"),t("code",[e._v("IE8")]),e._v("主要就是因为"),t("code",[e._v("defineProperty")]),e._v("无法兼容"),t("code",[e._v("IE8")]),e._v("，其他浏览器也会存在轻微兼容问题。")]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" obj "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("__x")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nObject"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("defineProperty")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"x"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("set")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("x")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"watch"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("__x "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("get")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("__x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nobj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("x "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("11")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// watch")]),e._v("\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("obj"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 11")]),e._v("\n")])])]),t("p",[t("code",[e._v("Vue3")]),e._v("使用"),t("code",[e._v("Proxy")]),e._v("实现数据劫持，"),t("code",[e._v("Object.defineProperty")]),e._v("只能监听属性，而"),t("code",[e._v("Proxy")]),e._v("能监听整个对象，通过调用"),t("code",[e._v("new Proxy()")]),e._v("，可以创建一个代理用来替代另一个对象被称为目标，这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。代理允许拦截在目标对象上的底层操作，而这原本是"),t("code",[e._v("Js")]),e._v("引擎的内部能力，拦截行为使用了一个能够响应特定操作的函数，即通过"),t("code",[e._v("Proxy")]),e._v("去对一个对象进行代理之后，我们将得到一个和被代理对象几乎完全一样的对象，并且可以从底层实现对这个对象进行完全的监控。"),t("code",[e._v("Proxy")]),e._v("对象是"),t("code",[e._v("ES6")]),e._v("引入的新特性，"),t("code",[e._v("Vue3")]),e._v("放弃使用了"),t("code",[e._v("Object.defineProperty")]),e._v("，而选择了使用更快的原生"),t("code",[e._v("Proxy")]),e._v("，即是在兼容性方面更偏向于现代浏览器。")]),e._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" target "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("a")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" proxy "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Proxy")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("set")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" receiver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" \n        console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"watch"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" Reflect"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("set")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" receiver"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("get")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" receiver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" \n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nproxy"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("11")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// watch")]),e._v("\nconsole"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("target"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// { a: 11 }")]),e._v("\n")])])]),t("h3",{attrs:{id:"_12-vue3和vue2生命周期函数有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue3和vue2生命周期函数有什么区别"}},[e._v("#")]),e._v(" 12.  vue3和vue2生命周期函数有什么区别？")]),e._v(" "),t("p",[e._v("vue3组合式api取消了beforeCreated和created钩子函数， 采用setup钩子函数代替，且里面不能使用this")]),e._v(" "),t("p",[e._v("vue3里面的组件销毁的钩子函数换成了beforeUnmount和unmounted 之前是destroyed")]),e._v(" "),t("p",[e._v("但是要注意，如果vue3使用vue2的选项式写法，之前的钩子函数还是可以使用")]),e._v(" "),t("p",[e._v("vue3的组合式api生命周期函数 要比 vue2选项式 API 的的生命周期函数 多个前缀 on，而且要单独引入")]),e._v(" "),t("h3",{attrs:{id:"_13-vue2里面父子组件的生命周期顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue2里面父子组件的生命周期顺序"}},[e._v("#")]),e._v(" 13. vue2里面父子组件的生命周期顺序")]),e._v(" "),t("p",[e._v("创建： 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted")]),e._v(" "),t("p",[e._v("更新： 父beforeUpdate->子beforeUpdate->子updated->父updated")]),e._v(" "),t("p",[e._v("销毁： 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")]),e._v(" "),t("p",[e._v("vue3：  父setup -> 父onBeforeMount -> 子setup ->子onBeforeMount -> 子onMounted-> 父onMounted  （记住父最后挂载到页面上）")]),e._v(" "),t("h3",{attrs:{id:"_14-props传递普通数据类型-和复杂数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-props传递普通数据类型-和复杂数据类型"}},[e._v("#")]),e._v(" 14. props传递普通数据类型，和复杂数据类型")]),e._v(" "),t("p",[e._v("vue是单向数据流，只能父组件修改数据，同步给子组件。子组件是不能修改父组件的数据的。")]),e._v(" "),t("p",[e._v("但是如果父向子传值是复杂数据类型，那么在子组件里面 修改 复杂数据类型的某个属性，是可以的，vue不会给你报错，也不会有警告，只有当我们把对象的地址进行了修改，vue才会提示我们，子组件不能修改父组件的值")]),e._v(" "),t("h3",{attrs:{id:"_15-vue2与3的父子通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue2与3的父子通信"}},[e._v("#")]),e._v(" 15. vue2与3的父子通信")]),e._v(" "),t("p",[e._v("vue3的父子通信")]),e._v(" "),t("p",[e._v("父向子")]),e._v(" "),t("ol",[t("li",[e._v("通过v-bind绑定属性，将父组件数据传递给子组件")]),e._v(" "),t("li",[e._v("子组件通过 defineProps 定义一个属性，接受父组件传递过来的值")])]),e._v(" "),t("p",[e._v("子向父")]),e._v(" "),t("ol",[t("li",[e._v("子组件通过defineEmit 定义一个事件类型，然后再方法里面通过emits('事件名称', 参数)  通知父组件去修改")]),e._v(" "),t("li",[e._v("在父组件的模板上面 通过 @自定义事件='父组件函数' 监听子组件触发的函数")]),e._v(" "),t("li",[e._v("在父组件的函数里面，更新父组件自己的数据")])]),e._v(" "),t("p",[e._v("vue2")]),e._v(" "),t("p",[e._v("父向子传值")]),e._v(" "),t("ol",[t("li",[e._v("在父组件里面，给子组件上面绑定属性，可以传递静态的值，也可以传递变量，就是通过v-bind")]),e._v(" "),t("li",[e._v("在子组件里面，通过props，接受父组件传递过来的数据。（这个地方vue3改变很大，需要通过defineProps来定义 props属性）")])]),e._v(" "),t("h3",{attrs:{id:"_16-props传递给子组件-子组件不更新的情况-vue2示例代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-props传递给子组件-子组件不更新的情况-vue2示例代码"}},[e._v("#")]),e._v(" 16. props传递给子组件，子组件不更新的情况 --- vue2示例代码")]),e._v(" "),t("p",[e._v("我们将子组件传递进来的数据， 做一个拷贝，在子组件的data上面，定义一个子组件自己的数据，然后将父组件传递进来的数据，作为改数据的初始值")]),e._v(" "),t("p",[e._v("这个时候 data数据，是子组件自己的，那么我们改变自己data上面的数据，是不会报错的")]),e._v(" "),t("p",[e._v("这时可以通过watch函数监听，和父组件的数据保持同步")]),e._v(" "),t("h3",{attrs:{id:"_17-vue2-与-vue3-父子孙-传值方式-vue2中内置组件访问方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue2-与-vue3-父子孙-传值方式-vue2中内置组件访问方法"}},[e._v("#")]),e._v(" 17. vue2 与 vue3 父子孙 传值方式 --  vue2中内置组件访问方法 ？")]),e._v(" "),t("ol",[t("li",[e._v("最原始的 父组件传递给子组件，子组件定义props接收，最后子组件再将这个数据传递给孙子组件")]),e._v(" "),t("li",[e._v("provide + inject -- 一个组件提供数据，下面的子孙等组件那个需要，就通过inject注入")]),e._v(" "),t("li",[e._v("$root找根组件， $parent 找当前组件的父组件， 这两种方式不推荐使用，因为会限制组件的使用场景")]),e._v(" "),t("li",[e._v("vue2 和 vue3 都有 provide 和 inject， 仅仅语法格式不一样")]),e._v(" "),t("li",[e._v("ref -- 获取页面上 dom元素，或者组件实例。 只不过vue3里面，需要子组件手动向外抛出defineExpose一些数据，外面才能使用\n"),t("ol",[t("li",[e._v('vue2的写法  在页面上 直接写 ref="aa", 在js里面 通过this.$refs.aa.xxx')]),e._v(" "),t("li",[e._v('vue3的写法 定义一个ref值 const aa = ref(); 在html上面 通过 ref="aa"绑定； js里面，通过aa.value 访问组件或者dom元素')])])])]),e._v(" "),t("h3",{attrs:{id:"_19-vue3里面一个对象没有通过ref和reactive包装-也可以有响应式的效果吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue3里面一个对象没有通过ref和reactive包装-也可以有响应式的效果吗"}},[e._v("#")]),e._v(" 19. vue3里面一个对象没有通过ref和reactive包装，也可以有响应式的效果吗？")]),e._v(" "),t("p",[e._v("可以，但是有前提条件")]),e._v(" "),t("p",[e._v("我们可以在一个函数里面，写一个另一个响应式数据的改变，然后再把非响应式数据进行更改，这样在响应式数据触发页面更新的时候，顺带着会更新我们非响应式的对象数据")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const obj = {\n    name: '我不是响应式对象上的属性'\n}\nconst num = ref(1)\n\nconst updateList = () => {\n    num.value++ // num是响应式数据，他一改变就会触发页面更新，因为我们的obj上面的值在js里面也发生了改变\n    // 所以 页面更新的时候，就会自动读取最新的obj的值，obj就看起来像响应式数据一样，其实不是\n    obj.name+= '$'\n}\n")])])]),t("h3",{attrs:{id:"_20-vue更新dom是异步的-nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue更新dom是异步的-nexttick"}},[e._v("#")]),e._v(" 20. vue更新dom是异步的 -- nextTick")]),e._v(" "),t("ol",[t("li",[e._v("当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，（只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更），直到下一个事件循环才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新 -- 提升效率")]),e._v(" "),t("li",[t("code",[e._v("nextTick()")]),e._v(" 可以在状态改变后立即使用，以等待 DOM 更新完成。你可以传递一个回调函数作为参数，或者 await 返回的 Promise")]),e._v(" "),t("li",[e._v("工作里面也可以使用setTime（宏任务）， promise是微任务")]),e._v(" "),t("li",[e._v("不用说，自己记忆： 怎么样比喻宏任务和微任务。 假设你在银行办业务， 你后面有5个人排队，5个人就是宏任务，。你自己有存取，买理财，买基金等等 这个是你自己的微任务")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const add = () => {\n  count.value++\n  count.value++\n  count.value++\n  count.value++\n  console.log(1,document.querySelector('.box').innerText);\n\n  nextTick(() => {\n    console.log(2,document.querySelector('.box').innerText);\n  })\n}\n\n")])])]),t("blockquote",[t("p",[e._v("ref 与 reactive 区别 -- 高级回答 （了解即可）")])]),e._v(" "),t("p",[e._v("ref: 如果使用的是基本类型响应式依赖Object.defineProperty( )，如果ref使用的是引用类型，底层ref会借助reactive的proxy 定义响应式")]),e._v(" "),t("p",[e._v("reactive:  参数只接受引用类型，基于Es6的Proxy实现， "),t("code",[e._v("ref")]),e._v(" 本质也是 "),t("code",[e._v("reactive")]),e._v("，"),t("code",[e._v("ref(obj)")]),e._v("等价于 "),t("code",[e._v("reactive({value: obj})")])]),e._v(" "),t("p",[e._v("一般选择ref， 如果选择reactive，可以使用"),t("strong",[e._v("toRefs进行导出到页面使用")])]),e._v(" "),t("p",[t("strong",[e._v("const")]),e._v(" { a, b, c } = "),t("strong",[e._v("toRefs")]),e._v("(state)")]),e._v(" "),t("h3",{attrs:{id:"_21-toref-和-torefs的使用场景-难-了解即可-vue3的内容-或者是这个问题-defineprops传值使用-ref-响应式失效"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-toref-和-torefs的使用场景-难-了解即可-vue3的内容-或者是这个问题-defineprops传值使用-ref-响应式失效"}},[e._v("#")]),e._v(" 21.toRef 和 toRefs的使用场景 （难--了解即可，vue3的内容）--- 或者是这个问题： defineProps传值使用 ref 响应式失效")]),e._v(" "),t("p",[e._v("1.toRef可以为响应式源对象上 某一个 属性新创建一个 ref，这个值会保持其源属性的响应式连接")]),e._v(" "),t("p",[e._v("2.toRefs可以为整个源对象，创建响应式连接，也可以进行解构，包装该对象每一个属性都是响应式的")]),e._v(" "),t("ol",[t("li",[e._v("一般用在父组件向子组件传递 props的值的时候，")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n\t<div>{{ msg }}</div>\n</template>\n<script setup>\nimport { ref } from \"vue\";\n// 接受来自父组件的传参\nconst props = defineProps({\n  data: String,\n});\nconst msg = ref(props.data); //这样写代码 msg和父组件的data就失去了响应式的连接了\n\n此时父组件改变 data 的值，子组件 msg 无法响应 data 的变化。\n因为 ref 是对传入数据的拷贝，原始值 data 的改变并不影响 msg\n但 toRef 是对传入数据的引用，原始值 data 改变会影响 msg\n\n正确做法：\n// 方法1：\nconst msg = toRef(props, 'data');\n// 方法2：\nconst { data } = toRefs(props);\n\n")])])]),t("h3",{attrs:{id:"v-model的语法糖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-model的语法糖"}},[e._v("#")]),e._v(" v-model的语法糖")]),e._v(" "),t("p",[e._v("原生元素和自定义组件")]),e._v(" "),t("h3",{attrs:{id:"_21-v-model在vue2和vue3里面的原理及区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-v-model在vue2和vue3里面的原理及区别"}},[e._v("#")]),e._v(" 21. v-model在vue2和vue3里面的原理及区别")]),e._v(" "),t("blockquote",[t("p",[e._v("v-model 的好处就是 父组件不用写 v-bind，也不用写@监听一个事件，也不用在父组件里面定义一个方法，去修改父组件的值。v-model自动给我们都做好了")])]),e._v(" "),t("p",[e._v("vue3里面")]),e._v(" "),t("p",[e._v("1.默认情况下，"),t("code",[e._v("v-model")]),e._v(" 在组件上都是使用 "),t("code",[e._v("modelValue")]),e._v(" 作为 prop，并以 "),t("code",[e._v("update:modelValue")]),e._v(" 作为对应的事件")]),e._v(" "),t("p",[e._v("2.也可以给 "),t("code",[e._v("v-model")]),e._v(" 指定一个参数来更改这些名字， 这样一个组件上面，就可以使用多个v-model")]),e._v(" "),t("p",[e._v("vue2里面")]),e._v(" "),t("ol",[t("li",[e._v("一个组件只能使用哪一个v-model， 语法糖就是 value属性作为props，事件就是input事件")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('原生元素上面\n<input v-model="searchText" />\n\n<input\n  :value="searchText"\n  @input="searchText = $event.target.value"\n/>\n\n自定义组件上面使用v-model\n<CustomInput v-model="searchText" />\n会被转换为下面的形式 （语法糖）\n<CustomInput\n  :modelValue="searchText"\n  @update:modelValue="newValue => searchText = newValue"\n/>\n\n绑定多个v-model\n<UserName\n  v-model:first-name="first"\n  v-model:last-name="last"\n/>\n\n')])])])])}),[],!1,null,null,null);t.default=v.exports}}]);